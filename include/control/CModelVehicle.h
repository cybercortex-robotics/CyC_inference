// Copyright (c) 2025 CyberCortex Robotics SRL. All rights reserved
// Author: Sorin Mihai Grigorescu

#ifndef CModelVehicle_H_
#define CModelVehicle_H_

#include "CCR_TYPES.h"
#include <iostream>
#include "CBaseStateSpaceModel.h"
#include "CLinearFirstOrderSystem.h"
#pragma warning(disable : 4275)
#include <libconfig.h++>
#pragma warning(default : 4275)
#include "os/CFileUtils.h"

#define ModelVehicle_NumStates  5
#define ModelVehicle_NumInputs  2
#define ModelVehicle_NumOutputs 5

struct CModelVehicle : public CBaseStateSpaceModel
{
public:
    enum VehicleType
    {
        VehicleType_Ackermann       = 0,
        VehicleType_Differential    = 1
    };
    
public:
    CModelVehicle(const VehicleType _vehicle_type,
        const float _vehicle_length,
        const float _vehicle_width,
        const float _full_vehicle_length,
        const float _full_vehicle_width,
        const float _wheel_radius,
        const float _max_steering_angle,
        const float _max_steering_rate,
        const float _max_forward_speed,
        const float _max_reverse_speed,
        const float _max_acceleration,
        const CCR_INT _pulses_per_rotation_left,
        const CCR_INT _pulses_per_rotation_right);
    CModelVehicle(const std::string& _vehicle_model_file);
    CModelVehicle(const CModelVehicle&) = default;
    CModelVehicle(CModelVehicle&&) = default;
    CModelVehicle& operator=(const CModelVehicle&) = default;
    CModelVehicle& operator=(CModelVehicle&&) = default;
    ~CModelVehicle() = default;

    virtual bool step(const float& _dt, const Eigen::VectorXf& _u);

    void linearizeMethod1(const float &velocity, const float &yaw_angle, const float &ref_steer_angle, const float &dt);
    void linearizeMethod2(const float velocity, const float yaw_angle, const float ref_steer_angle, const float dt);

private:
    void init();
    void step_ackermann(const float& _dt, const Eigen::VectorXf& _u);
    void step_differential(const float& _dt, const Eigen::VectorXf& _u);
    
public:
    VehicleType m_VehicleType;                      // Type of vehicle model (ackermann or differential)
    float       m_fLongDistWheels = -1.f;           // Distance between front and rear axles [m]
    float       m_fLatDistWheels = -1.f;            // Distance between lateral axles        [m]
    float       m_fVehicleLength = -1.f;            // Lenght of the vehicle    [m]
    float       m_fVehicleWidth = -1.f;             // Width of the vehicle     [m]
    float       m_fWheelRadius = -1.f;              // Wheel radius             [m]
    float       m_fWheelCircumference = -1.f;       // Wheel circumference      [m]     (2*PI*radius)
    float       m_fMaxSteeringAngleRad = -1.f;      // Maximum steering angle   [rad]
    float       m_fSteeringRateResolution = -1.f;   // Maximum steering speed   [rad/s]
    float       m_fMaxForwardSpeed = -1.f;          // Maximum speed            [m/s]
    float       m_fMaxReverseSpeed = -1.f;          // Minimum speed            [m/s]
    float       m_fMaxAcceleration = -1.f;          // Maximum acceleration     [m/ss]
    CCR_INT     m_iPulsesPerRotationLeft = 1;       // Pulses generated by a full rotation
    CCR_INT     m_iPulsesPerRotationRight = 1;      // Pulses generated by a full rotation

private:
    CLinearFirstOrderSystem velocity_sim;
};

#endif /* CModelVehicle_H_ */
